# -*- coding: utf-8 -*-
"""EDA CHARGING STATIONS by SAAD UR RAHMAN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1manPeAfY4HcPANlSGAVW5zGe-vU7_NLS

# **EDA BY SAAD UR RAHMAN - CHARGING STATIONSS**

# **INITIAL PREPARATION**
"""

#importing all necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import statistics

#reading csv file
fresh_data = pd.read_csv("charging.csv")

#storing a caopy into another variable
df=fresh_data.copy()
df.head(4)

#printing info and isnull to cheeck fron number of non null values, data types of columns and number of null values
print(df.info())
print(df.isnull().sum())

#storing rowss with null values as seperate dataframe
null_values = df[df.isnull().any(axis=1)]
null_values

#dropping the null values from the main dataframe
df.dropna(inplace=True)
df.isnull().sum()

#Finding rows with Meter Total(Wh) > 0 but total duration = 0, this means the charger can charger instantaniosly without time-loss, which is impossible
mask = (df['Total Duration (s)'] == 0) & (df['Meter Total(Wh)'] != 0)

#storing it in another dataframe
df_error = df[mask]
df_error

#droppping the above rows from the main dataframe
df.drop(df_error.index, inplace=True)
df.reset_index(drop=True, inplace=True)
df.shape

#Checking whether the readings in 'Meter Total(Wh)' column equals 'Meter End(Wh)' - 'Meter Start (Wh)'
df[((df['Meter End(Wh)'] - df['Meter Start (Wh)']) - df['Meter Total(Wh)']) > 0.1]

"""# **INITIAL EDA**"""

#plotting a scatter plot between 'Meter Start (Wh)' and 'Meter End(Wh)'
y = df['Meter Start (Wh)']
x = df['Meter End(Wh)']
plt.figure(figsize=(15,8))
sns.scatterplot(x=x, y=y, hue='Charger_name', size='Meter Total(Wh)', data=df)
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()

#plotting a scatter plot between 'Meter Start (Wh)' and 'Meter Total(Wh)'
y = df['Meter Start (Wh)']
x = df['Meter Total(Wh)']
plt.figure(figsize=(15,8))
sns.scatterplot(x=x, y=y, hue='Charger_name', data=df)
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()

#plotting a scatter plot between 'Meter End(Wh)' and 'Meter Total(Wh)'
y = df['Meter End(Wh)']
x = df['Meter Total(Wh)']
plt.figure(figsize=(15,8))
sns.scatterplot(x=x, y=y, hue='Charger_name', data=df)
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()

#plotting a scatter plot between 'Meter Total(Wh)' and 'Total Duration (s)'
y = df['Meter Total(Wh)']
x = df['Total Duration (s)']/86000
plt.figure(figsize=(15,8))
sns.scatterplot(x=x, y=y, hue='Charger_name', data=df)
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()

"""# **DEALING WITH FAULTY VALUES - OUTLIERS, MISCALCULATIONS**"""

#printing the rows with outliers in Meter Total(Wh) column
df.nlargest(5, columns=['Meter Total(Wh)'])

#printing the rows with outliers in Total Duration (s) column
df.nlargest(5, columns=['Total Duration (s)'])

#Dropping the outliers from the dataframe
df.drop(df.nlargest(1, columns=['Meter Total(Wh)']).index, inplace=True)
df.drop(df.nlargest(3, columns=['Total Duration (s)']).index, inplace=True)

#resetting the index
df.reset_index(drop=True, inplace=True)
df.shape

#Copying main dataframe for some extra calculations
df_try = df.copy()

#Finding rows with Meter Total(Wh) == 0, these are rows whose values won't be used to calculate speed of charger
#I am assuming that zero charging means that the charger and car were not compatible, or there was some fault with the METER of the charger
zero_charging = df_try[df_try['Meter Total(Wh)'] == 0]

#droppping the above rows from the new dataframe
df_try.drop(zero_charging.index, inplace=True)
df_try.reset_index(drop=True, inplace=True)
df_try.shape

#Calculating speed of charging for eact instance
df_try['Meter Speed'] = df_try['Meter Total(Wh)']/df_try['Total Duration (s)']

#reseting index
df_try.reset_index(drop=True, inplace=True)
df_try

# Grouping by 'Charger_name' and then calculating the mean speed for each charger
df_speed = df_try.groupby('Charger_name')['Meter Speed'].mean().reset_index(name='Mean Speed')
df_speed

#Joining error and speed dataframe in 'Charger Name'
merged_df = pd.merge(df_error, df_speed, on='Charger_name')

#Calculating the 'Total Duration (s)' for each instance to replace the wrong value
for index, row in merged_df.iterrows():
    merged_df.loc[index, 'Total Duration (s)'] = row['Meter Total(Wh)'] / row['Mean Speed']

#Stroring the required columns in new dataframe
df_error_corrected = merged_df[['Start Time', 'Meter Start (Wh)','Meter End(Wh)','Meter Total(Wh)','Total Duration (s)','Charger_name']]
df_error_corrected

#plotting a scatter plot between 'Meter Total(Wh)' and 'Total Duration (s)' to check for outliers
y = df_error_corrected['Meter Total(Wh)']
x = df_error_corrected['Total Duration (s)']/86000
plt.figure(figsize=(10,5))
sns.scatterplot(x=x, y=y, hue='Charger_name', data=df_error_corrected)
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()

#Concatinating main and corrected datafamres
df = pd.concat([df, df_error_corrected], ignore_index=True)

# Display the updated dataframe and check is everthing is alright
print(df.info())
print('\n')
print(df.isnull().sum())
print('\n')
print(df.shape)
print('\n')
df.head(5)

"""# **ADJUSTING THE TIMESTAMP DATA FOR BETTER USE**"""

#creating a function to split date-time into smaller parts
def split_datetime(start_time):
  """
  This function takes a string in the format "31.08.2018 06:45" and returns a dictionary containing the date, year, month, day, time, and year_month as separate values.
  """
  # Splitting the string into date and time parts
  date_time = start_time.split()

  # Splitting the date part into day, month, and year
  date_parts = date_time[0].split('.')

  # Converting the date parts to integers
  day = int(date_parts[0])
  month = int(date_parts[1])
  year = int(date_parts[2])

  # Splitting the time part into hours and minutes
  time_parts = date_time[1].split(':')

  # Converting the time parts to integers
  hour = int(time_parts[0])
  minute = int(time_parts[1])

  # Creating a dictionary to store the results
  result = {
    'date': date_time[0],
    'year': year,
    'month': month,
    'day': day,
    'time': date_time[1],
    'hour': hour,
    'minute': minute,
    'year_month': str(year) + '-' + str(month)
  }

  return result

#Storing the returned dictionary into new columns
df[['date', 'year', 'month', 'day', 'time', 'hour', 'minute', 'year_month']] = df['Start Time'].apply(split_datetime).apply(pd.Series)

#displaing first 5 rows
df.head(5)

#sorting values based time and date in ascending order
df= df.sort_values(by=['year','month','date','hour','minute'], ascending=True)
df.reset_index(drop=True, inplace=True)
df.head(5)

"""# **SOME STATISTICAL DATA SUCH AS COUNT, MEAN, MAX, MIN, STD**"""

df.nunique()

#storing a copy of dataframe as df_adj
df_adj=df.copy()

#converting Watts to KiloWatts and seconds into hours, these are considered standard unit in the industry
df_adj[['Meter Total(Wh)','Meter Start (Wh)','Meter End(Wh)']] = df_adj[['Meter Total(Wh)','Meter Start (Wh)','Meter End(Wh)']]/1000
df_adj['Total Duration (s)'] = df_adj['Total Duration (s)']/3600

df_adj[['Meter Start (Wh)','Meter End(Wh)','Meter Total(Wh)','Total Duration (s)']].describe()

df_adj[['Meter Start (Wh)','Meter End(Wh)','Meter Total(Wh)','Total Duration (s)']].median()

"""# **EDA BASED ON CHARGER NAMES**"""

# Groupping the data by 'Charger_name'
grouped_data = df_adj.groupby('Charger_name')

# Creating a figure with 8 columns and 2 rows
fig, axes = plt.subplots(nrows=2, ncols=8, figsize=(25, 10))

# Plotting a line plot for 'Meter Start (Wh)' for each group
for i, (name, group) in enumerate(grouped_data):
    ax = axes[i // 8, i % 8]  # Select the appropriate subplot
    group['Meter Total(Wh)'].plot(kind='line', ax=ax, title=name)
    ax.spines[['top', 'right']].set_visible(False)

# Adjusting the spacing between subplots
plt.tight_layout()

# Displaying the plot
plt.show()

# Groupping the data by 'Charger_name'
grouped_data = df_adj.groupby('Charger_name')

# Creating a figure with 8 columns and 2 rows
fig, axes = plt.subplots(nrows=2, ncols=8, figsize=(25, 10))

# Plotting a line plot for 'Meter Start (Wh)' for each group
for i, (name, group) in enumerate(grouped_data):
    ax = axes[i // 8, i % 8]  # Select the appropriate subplot
    group['Meter Start (Wh)'].plot(kind='line', ax=ax, title=name)
    ax.spines[['top', 'right']].set_visible(False)

# Adjusting the spacing between subplots
plt.tight_layout()

# Displaying the plot
plt.show()

#Calculating speed for every instance
df_adj['Meter Speed'] = df_adj['Meter Total(Wh)']/df_adj['Total Duration (s)']
df_adj.head(5)

# Groupping the data by 'Charger_name'
grouped_data = df_adj.groupby('Charger_name')

# Creating a figure with 8 columns and 2 rows
fig, axes = plt.subplots(nrows=2, ncols=8, figsize=(25, 10))

# Plot a line plot for 'Meter Start (Wh)' for each group
for i, (name, group) in enumerate(grouped_data):
    ax = axes[i // 8, i % 8]  # Select the appropriate subplot
    group['Meter Speed'].plot(kind='bar', ax=ax, title=name)
    ax.spines[['top', 'right']].set_visible(False)

# Adjust the spacing between subplots
plt.tight_layout()

# Display the plot
plt.show()

#Plotting number of times each charger was used
y = df_adj['Charger_name'].value_counts()
x = df_adj['Charger_name'].value_counts().index
plt.figure( figsize=(12,5))
plt.bar(x,y)
plt.xticks(rotation=90)

#Setting labels
plt.xlabel('Charger Name')
plt.ylabel('Number of times used')

# Adding the number of chargers above each bar
for i, v in enumerate(y):
    plt.text(i, v, str(v), ha='center', va='bottom')

#plotting
plt.show()

#Grouping by charger name to calculate total KWh consumption of each charger
df_grouped = df_adj.groupby('Charger_name')['Meter Total(Wh)'].sum().reset_index()
df_grouped = df_grouped.sort_values(by='Meter Total(Wh)', ascending=False)
df_grouped.plot(kind='bar',  figsize=(12,5), x='Charger_name', y='Meter Total(Wh)')

# Adding the number of chargers above each bar
for i, v in enumerate(df_grouped['Meter Total(Wh)']):
    plt.text(i, v, str(int(v)), ha='center', va='bottom')

#Setting labels
plt.xlabel('Charger Name')
plt.ylabel('Energy Consumption(kWh)')
plt.show()

# Grouping by 'hour' and count the number of instances
df_temp = df_adj.copy()

#dropping rows with null values, Meter Total and Duration both are 0
df_temp.dropna(inplace=True)

#I am assuming that zero charging means that the charger and car were not compatible, or there was some fault with the METER of the charger
zero_charging = df_temp[df_temp['Meter Total(Wh)'] == 0]

#droppping the above rows from the new dataframe
df_temp.drop(zero_charging.index, inplace=True)
df_temp.reset_index(drop=True, inplace=True)

#Grouping by charger name to calculate total KWh consumption of each charger
df_grouped = df_temp.groupby('Charger_name')['Meter Speed'].mean().reset_index()
df_grouped = df_grouped.sort_values(by='Meter Speed', ascending=False)
df_grouped.plot(kind='bar',  figsize=(12,5), x='Charger_name', y='Meter Speed')

# Add the number of chargers above each bar
for i, v in enumerate(df_grouped['Meter Speed']):
    plt.text(i, v, str(round(v, 3)), ha='center', va='bottom')

#Adding labels
plt.xlabel('Charger Name')
plt.ylabel('Charginf Speed (kWh)')
plt.show()

#Grouping by charger name to calculate average Speed of each charger per session
df_grouped = df_adj.groupby('Charger_name')['Meter Total(Wh)'].mean().reset_index()
df_grouped.plot(kind='bar', figsize=(12,5), x='Charger_name', y='Meter Total(Wh)')

# Adding the number of chargers above each bar
for i, v in enumerate(df_grouped['Meter Total(Wh)']):
    plt.text(i, v, str(round(v, 2)), ha='center', va='bottom')

#Adding labels
plt.xlabel('Charger Name')
plt.ylabel('Aveerge Speed')
plt.show()

"""# **TEMPORAL DATA EXPLORATION**"""

#Plotting Meter Start for each instance
df_adj['Meter Start (Wh)'].plot(kind='line', figsize=(12, 5), title='Meter Start Readings')
plt.gca().spines[['top', 'right']].set_visible(False)

#Adding Label
plt.gca().set_ylabel('Meter Start Readings(kW)')

#plotting
plt.show()

#Plotting Meter End for each instance
df_adj['Meter End(Wh)'].plot(kind='line', figsize=(12,5), title='Meter End Readings')
plt.gca().spines[['top', 'right']].set_visible(False)

#Adding Label
plt.gca().set_ylabel('Meter End Readings(kW)')

#plotting
plt.show()

#Plotting Meter Total for each instance
df_adj['Meter Total(Wh)'].plot(kind='line', figsize=(12,5), title='Meter Total(kWh)')
plt.gca().spines[['top', 'right']].set_visible(False)

#Adding Label
plt.gca().set_ylabel('Meter Total(kWh)')

#plotting
plt.show()

#Gropuing by 'year_month' and summing Meter total for each year_month
df_grouped = df_adj.groupby('year_month')['Meter Total(Wh)'].sum().reset_index()
df_grouped.plot(kind='bar', figsize=(12,5), x='year_month', y='Meter Total(Wh)')

#Adding labels
plt.xlabel('Year Month')
plt.ylabel('Meter Total(kW)')
plt.xticks(rotation=90)

# Adding the number of chargers above each bar
for i, v in enumerate(df_grouped['Meter Total(Wh)']):
    plt.text(i, v, str(int(v)), ha='center', va='bottom')

#plotting
plt.show()

# Creating the scatter plot
start_time = df_adj['year_month']
charger_name = df_adj['Charger_name']
plt.figure(figsize=(12, 6))
plt.scatter(start_time, charger_name)

# Labeling the axes
plt.xlabel('Months', fontsize=12)
plt.ylabel('Chargers', fontsize=12)
plt.xticks(rotation=90)

# Adding a title
plt.title('Scatter Plot of Months vs Charger Name', fontsize=14)

# plotting
plt.show()

# Grouping by 'hour' and count the number of instances
df_sorted_grouped = df_adj.groupby('hour').size().reset_index(name='Number of Chargers Used')

# Plotting a bar chart
df_sorted_grouped.plot(kind='bar', figsize=(12,5), x='hour', y='Number of Chargers Used')

# Adding bar numbers
for i, v in enumerate(df_sorted_grouped['Number of Chargers Used']):
    plt.text(i, v, str(v), ha='center', va='bottom')

# plotting
plt.show()

# Grouping by 'hour' and count the number of instances
df_sorted_grouped = df_adj.groupby('hour')['Meter Total(Wh)'].sum().reset_index(name='Energy Consumption')

# Plotting a bar chart
df_sorted_grouped.plot(kind='bar', figsize=(12,5), x='hour', y='Energy Consumption')

# Adding bar numbers
for i, v in enumerate(df_sorted_grouped['Energy Consumption']):
    plt.text(i, v, str(int(v)), ha='center', va='bottom')

# Showing the plot
plt.show()

# Grouping by 'hour' and count the number of instances
df_temp = df_adj.copy()

#dropping rows with null values, Meter Total and Duration both are 0
df_temp.dropna(inplace=True)

#I am assuming that zero charging means that the charger and car were not compatible, or there was some fault with the METER of the charger
zero_charging = df_temp[df_temp['Meter Total(Wh)'] == 0]

#droppping the above rows from the new dataframe
df_temp.drop(zero_charging.index, inplace=True)
df_temp.reset_index(drop=True, inplace=True)
df_temp.shape

df_sorted_grouped = df_temp.groupby('hour')['Meter Speed'].mean().reset_index(name='Count')

# Ploting a bar chart
df_sorted_grouped.plot(kind='bar', figsize=(12,5), x='hour', y='Count')

# Adding bar numbers
for i, v in enumerate(df_sorted_grouped['Count']):
    plt.text(i, v, str(round(v,2)), ha='center', va='bottom')

# Showing the plot
plt.show()

# Defineing the number of rows and columns for the subplot grid
nrows = 2
ncols = 8

# Createing a figure and a set of subplots
fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(25, 8))

# Flattening the axes object
axes = axes.flat

# Iterating over unique charger IDs and create bar charts
charger_ids = df_adj['Charger_name'].unique()
for i, charger_id in enumerate(charger_ids):

    df_charger = df_adj[df_adj['Charger_name'] == charger_id]
    df_charger_grouped = df_charger.groupby('hour').size().reset_index(name='Count')
    total_count = df_charger_grouped['Count'].sum()
    df_charger_grouped.plot(kind='bar', x='hour', y='Count', ax=axes[i], title=f'Charger ID: {charger_id}')

    # Adding total count as a legend
    axes[i].legend([f'Total: {total_count}'])

# Adjusting spacing between subplots
plt.tight_layout(pad=5.0)

# Showing the plot
plt.show()

#Setting the size of the plot
plt.figure( figsize=(12,5))
# Creating the bell curve
sns.distplot(df_adj['Meter Total(Wh)'], kde=True, kde_kws={'color': 'blue'}, color='grey')

# Calculate the mean, standard deviation, and median
mean = statistics.mean(df_adj['Meter Total(Wh)'])
stddev = statistics.stdev(df_adj['Meter Total(Wh)'])
median = statistics.median(df_adj['Meter Total(Wh)'])

# Print the statistics on the plot
plt.text(25, 0.08, f"Mean: {mean:.2f}", color='black')
plt.text(25, 0.065, f"Standard deviation: {stddev:.2f}", color='black')
plt.text(25, 0.05, f"Median: {median:.2f}", color='black')

# Set xticks interval to 10
plt.xticks(range(0, 60, 3))
plt.xticks(rotation=45)


# Adding labels and title
plt.xlabel('Meter Total(kW)')
plt.ylabel('Frequency')
plt.title('Bell Curve of Energy Consumption(kW)')

#plotting
plt.show()

#setting the size of the plot
plt.figure( figsize=(12,5))

# Creating the bell curve
sns.distplot(df_adj['Meter Start (Wh)'], kde=True, kde_kws={'color': 'blue'}, color='grey')

# Adding labels and title
plt.xlabel('Meter Total(Wh)')
plt.ylabel('Frequency')
plt.title('Bell Curve of Meter Total(Wh)')

# Showing the plot
plt.show()

#setting the size of the plot
plt.figure( figsize=(12,5))

# Creating the bell curve
sns.distplot(df_adj['Meter End(Wh)'], kde=True, kde_kws={'color': 'blue'}, color='grey')

# Adding labels and title
plt.xlabel('Meter Total(Wh)')
plt.ylabel('Frequency')
plt.title('Bell Curve of Meter Total(Wh)')

#Plotting
plt.show()

#Setting the size of the plot
plt.figure( figsize=(12,5))
# Creating the bell curve
sns.distplot(df_adj['Total Duration (s)'], kde=True, kde_kws={'color': 'blue'}, color='grey')

# Calculating the mean, standard deviation, and median
mean = statistics.mean(df_adj['Total Duration (s)'])
stddev = statistics.stdev(df_adj['Total Duration (s)'])
median = statistics.median(df_adj['Total Duration (s)'])

# Printing the statistics on the plot
plt.text(100, 0.03, f"Mean: {mean:.2f}", color='black')
plt.text(100, 0.025, f"Standard deviation: {stddev:.2f}", color='black')
plt.text(100, 0.02, f"Median: {median:.2f}", color='black')

# Setting xticks interval to 10
plt.xticks(range(0, 250, 10))
plt.xticks(rotation=45)

# Adding labels and title
plt.xlabel('Time Duration(Hours)')
plt.ylabel('Frequency')
plt.title('Bell Curve of Time Duration(Hours)')

#plotting
plt.show()

#Setting the size of the plot
plt.figure( figsize=(12,5))
# Creating the bell curve
sns.distplot(df_adj['Total Duration (s)'], kde=True, kde_kws={'color': 'blue'}, color='grey')

# Adding labels and title
plt.xlabel('Time Duration(Hours)')
plt.ylabel('Frequency')
plt.title('Bell Curve of Time Duration(Hours)')

# Setting xticks interval to 10
plt.xticks(range(0, 250, 10))
plt.xticks(rotation=45)
#plotting
plt.show()

"""# **UNWANTED CODE, MIGHT USE LATER**"""

def closest_value(number, array):

  # Calculating the absolute differences between the number and each element in the array
  differences = np.abs(array - number)

  # Finding the index of the element with the smallest absolute difference
  closest_index = np.argmin(differences)

  return df_speed['Charger_name'][closest_index]